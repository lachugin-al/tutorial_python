# Числовые значение неизменяемым, поэтому x не изменился вместе с y (поэтому создаетс новый объект число)
# Если бы это имена ссылались на изменяемый объект (к примеру: Списки), то x поменялся при изменении y

x = 1
y = x
y += 1
print(x, y)


# Линейный поиск в массиве
def array_search(a: list, n: int, x: int):
    """ Осуществляет поиск числа x в массиве a
        от 0 до n-1 индекса включительно.
        Возвращает индекс элемента x в массиве a.
        Или -1 если такого нет.
        Если в массиве несколько элементов
        равных x, то вернуть индекс первого по счету.
    """
    for k in range(n):
        if a[k] == x:
            return k
    return -1


def test_array_search():
    a1 = [1, 2, 3, 4, 5]
    m = array_search(a1, 5, 8)  # нет элемента
    if m == -1:
        print('#test1 - passed')
    else:
        print('#test1 - fail')

    a2 = [-1, -2, -3, -4, -5]
    m = array_search(a2, 5, -3)  # элемент -1 по индексу 2
    if m == 2:
        print('#test2 - passed')
    else:
        print('#test2 - fail')

    a3 = [10, 20, 30, 40, 50]
    m = array_search(a3, 5, 10)  # элемент 10 по индексу 0
    if m == 0:
        print('#test3 - passed')
    else:
        print('#test3 - fail')


test_array_search()


# Обращение массива
def invert_array(a: list, n: int):
    """ Обращение массива (задом-наперед)
        в рамках индексов от 0 до n-1
    """
    for k in range(n // 2):  # итерируемся до середины массива
        tmp = a[k]
        a[k] = a[n - 1 - k]
        a[n - 1 - k] = tmp

        # a[k], a[n - 1 - k] = a[n - 1 - k], a[k]
    return a


def test_invert_array():
    b1 = [1, 2, 3, 4, 5]
    print(b1)
    invert_array(b1, 5)
    print(b1)
    if b1 == [5, 4, 3, 2, 1]:
        print('#test4 - ok')
    else:
        print('#test4 - fail')

    b2 = [0, 0, 0, 0, 0, 10]
    print(b2)
    invert_array(b2, 6)
    print(b2)
    if b2 == [10, 0, 0, 0, 0, 0]:
        print('#test5 - ok')
    else:
        print('#test5 - fail')


test_invert_array()

# Циклический сдвиг в массиве
# это операция преобразования элементов в массиве
# бывает влево - сдвигаются элемены влево, а самый первый кладем в конец массива путем передвигания всех элементов
# бывает вправо - сдвигаются элемены вправо, а самый последний кладем в начало массива путем передвигания всех элементов

# влево
a = [0, 1, 2, 3]
n = len(a)
print(a)

tmp = a[0]
for k in range(n - 1):  # len(a) = 4, 4 -1 = 3 до 3 индекса (0 1 2) так как в последний индекс 3 неоткуда смещать справа
    a[k] = a[k + 1]
a[n - 1] = tmp
print(a)

# вправо
tmp = a[n - 1]  # последний элемент в массиве
for k in range(n - 2, -1, -1):  # обратный порядок поэтому первый элемент будет n-2 с шагом -1
    a[k + 1] = a[k]
a[0] = tmp
print(a)

# Решето Эратосфена
# поиск всех простых чисел (простое число делится только на 1 и на самого себя)
n = int(input())
a = [True] * n
a[0] = a[1] = False
for i in range(2, n):
    if a[i]:  # == True с проверкой уже заполненных чисел в массиве по циклу m с присваиванием False
        for m in range(i + i, n, i):  # присваиваем значения False числам i * 2 с шагом i
            a[m] = False  # присваиваем False всем числам i + i так как их уже можем поделить на 2

for i in range(n):
    print(i, '-', 'простое' if a[i] else 'составное')  # тернарный оператор
