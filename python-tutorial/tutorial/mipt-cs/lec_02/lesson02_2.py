# присваивание и кортежи

# у имен нет типов - типы только у объектов!!!

# объекты бывают изменяемыми и неизменяемыми
x = 2 + 3  # ссылка на объект 5 int
y = x  # ссылкаемся на объект с сылкой x
x += 1  # ссылается на новый объект

x = y = z = 0
x=1; y=2; z=3 # not good
x, y, z = 0, 0, 0 # (x, y, z) = (0, 0, 0)

x,y,z = z,y,x

t = 1,2,3,4,5
print(type(t)) # calss <'tuple'> кортеж - неизменяемый тип, но сам объект может изменяться еслии ссылаются на изменяемый тип
a,b,c,d,e = t # распаковал кортеж
print(a) # 1
a = t[1]
print(a) # 2
a,b,c, *rest = t # распаковал кортеж (в rest добавятся все элементы которые не распаковались в a,b,c)
*rest, d,e = t

print(t) # print(t[0], t[1], t[2] ...)
print(*t, sep=', ', end='!\n') # * является элементом поэлементной распаковки кортежа
# \n - перевод каретки new line

print(rest)
print(type(rest)) # list

# аннотация топов name в котором я ПРОЕДПОЛАГАЮ строку
def hello_n(name: str,
            n: int):
    for i in range(n):
        print(name, 'Hello')

hello_n('1', 2)
vasya = 'Vasya', 3 # кортеж
hello_n(*vasya) # распаковываем кортеж

# range - генератор арифметических прогрессий
pr1 = range(100)
print(pr1[99])

pr2 = range(1, 1*10, 2)
print(pr2)
print(pr2[0], pr2[1]) # 1 3
print(*pr2) # 1 3 5 ...

for x in pr2: # pr2 должен быть итерируемым объектом
    print(x)

# кортеж отличается от списка тем, что он изменяемый
# список и кортеж отличается от массива тем что в массив мы кладем однотиповые данные!!!
# список это последовательность ссылок на объекты
#           0       1       2
list_x = [(1,10), (2,20), (3,30)] # список кортежей

# range(3) - 3 не включительно
# можно итерироваться по list_x[i][i] у кортежа элемент по индексу 0 0
for i in range(len(list_x)):
    # temp = list_x[i] # присваиваем кортежу имя
    a, b = list_x[i] # можем распаковать кортеж сразу
    print(a, b) # 1 10

# мы можем бежать сразу по кортежу итерировать по ссылкам на кортеж t=1 --> list_x[0]
for t in list_x:
    a, b = t
    print(t) # (1, 10)

# если мы уверены что имеет только n элементов и их можно распаковать, то мы можем бежать сразу
# по n количеству элементов
for a, b in list_x:
    print(a, b) # 1 10

# номер итерации и кортеж x по индексу
for i, x in enumerate(list_x):
    print(i , x)

list_s = ['moscow', 'ekb', 'spb']
list_s.append('rostov') # добавляет в конец

# СЛОВАРИ И МНОЖЕСТВА - элементы не упорядочены!!!
# dict - словари
# set - множества
s={'moscow', 'ekb', 'spb'} # структура данных типа множество - можно добавлять элементы
s.add('rostov') # будучи изменяемым позволяет очень быстро выдать результат
# множества можно пересекать, объединять, вычитать, симетрик дифференсе

for element in s:
    print(element)

# словарь: кортеж ключ и значение
# значений может быть множество, ключей только уникальные значения

# dictionary
d = {'moscow' : 1,
     'ekb': 2,
     'spb': 2}
d['moscow'] = 4;
print(d['moscow'])

for key in d:
    print(key, d[key])